/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/client/styles.css":
/*!*********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/client/styles.css ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `body {\n\tmargin: 0;\n\tbackground-color: #fc0000;\n\t/* background-image: radial-gradient(ellipse at top, #335476 0.0%, #31506e 11.1%, #304b67 22.2%, #2f4760 33.3%, #2d4359 44.4%, #2c3f51 55.6%, #2a3a4a 66.7%, #293643 77.8%, #28323d 88.9%, #262e36 100.0%); */\n\theight: 100vh;\n\toverflow: hidden;\n\n\tfont-family: monospace;\n\tfont-weight: bold;\n\tletter-spacing: 0.06em;\n\tcolor: rgba(255, 255, 255, 0.75);\n}\n\n#c {\n\tdisplay: block;\n\ttouch-action: none;\n\ttransform: translateZ(0);\n}\n\n\n/*/////////////////////\n//        HUD        //\n/////////////////////*/\n\n\n.hud__score,\n.pause-btn {\n\tposition: fixed;\n\tfont-size: calc(14px + 2vw + 1vh);\n}\n\n.hud__score {\n\ttop: 0.65em;\n\tleft: 0.65em;\n\tpointer-events: none;\n\tuser-select: none;\n}\n\n.cube-count-lbl {\n\tfont-size: 0.46em;\n}\n\n.pause-btn {\n\tposition: fixed;\n\ttop: 0;\n\tright: 0;\n\tpadding: 0.8em 0.65em;\n}\n\n.pause-btn > div {\n\tposition: relative;\n\twidth: 0.8em;\n\theight: 0.8em;\n\topacity: 0.75;\n}\n\n.pause-btn > div::before,\n.pause-btn > div::after {\n\tcontent: '';\n\tdisplay: block;\n\twidth: 34%;\n\theight: 100%;\n\tposition: absolute;\n\tbackground-color: #fff;\n}\n\n.pause-btn > div::after {\n\tright: 0;\n}\n\n.slowmo {\n\tposition: fixed;\n\tbottom: 0;\n\twidth: 100%;\n\tpointer-events: none;\n\topacity: 0;\n\ttransition: opacity 0.4s;\n\twill-change: opacity;\n}\n\n.slowmo::before {\n\tcontent: 'SLOW-MO';\n\tdisplay: block;\n\tfont-size: calc(8px + 1vw + 0.5vh);\n\tmargin-left: 0.5em;\n\tmargin-bottom: 8px;\n}\n\n.slowmo::after {\n\tcontent: '';\n\tdisplay: block;\n\tposition: fixed;\n\tbottom: 0;\n\twidth: 100%;\n\theight: 1.5vh;\n\tbackground-color: rgba(0, 0, 0, 0.25);\n\tz-index: -1;\n}\n\n.slowmo__bar {\n\theight: 1.5vh;\n\tbackground-color: rgba(255, 255, 255, 0.75);\n\ttransform-origin: 0 0;\n}\n\n\n\n/*/////////////////////\n//       MENUS       //\n/////////////////////*/\n\n.menus::before {\n\tcontent: '';\n\tpointer-events: none;\n\tposition: fixed;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\tleft: 0;\n\tbackground-color: #000;\n\topacity: 0;\n\ttransition: opacity 0.2s;\n\ttransition-timing-function: ease-in;\n}\n\n.menus.has-active::before {\n\topacity: 0.08;\n\ttransition-duration: 0.4s;\n\ttransition-timing-function: ease-out;\n}\n\n.menus.interactive-mode::before {\n\topacity: 0.02;\n}\n\n\n\n/* Menu containers */\n.menu {\n\tpointer-events: none;\n\tposition: fixed;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\tleft: 0;\n\tdisplay: flex;\n\tflex-direction: column;\n\tjustify-content: center;\n\talign-items: center;\n\tuser-select: none;\n\ttext-align: center;\n\tcolor: rgba(255, 255, 255, 0.9);\n\topacity: 0;\n\tvisibility: hidden;\n\ttransform: translateY(30px);\n\ttransition-property: opacity, visibility, transform;\n\ttransition-duration: 0.2s;\n\ttransition-timing-function: ease-in;\n}\n\n.menu.active {\n\topacity: 1;\n\tvisibility: visible;\n\ttransform: translateY(0);\n\ttransition-duration: 0.4s;\n\ttransition-timing-function: ease-out;\n}\n\n.menus.interactive-mode .menu.active {\n\topacity: 0.6;\n}\n\n.menus:not(.interactive-mode) .menu.active > * {\n\tpointer-events: auto;\n}\n\n\n/* Common menu elements */\n\nh1 {\n\tfont-size: 4rem;\n\tline-height: 0.95;\n\ttext-align: center;\n\tfont-weight: bold;\n\tmargin: 0 0.65em 1em;\n}\n\nh2 {\n\tfont-size: 1.2rem;\n\tline-height: 1;\n\ttext-align: center;\n\tfont-weight: bold;\n\tmargin: -1em 0.65em 1em;\n}\n\n.final-score-lbl {\n\tfont-size: 5rem;\n\tmargin: -0.2em 0 0;\n}\n\n.high-score-lbl {\n\tfont-size: 1.2rem;\n\tmargin: 0 0 2.5em;\n}\n\nbutton {\n\tdisplay: block;\n\tposition: relative;\n\twidth: 200px;\n\tpadding: 12px 20px;\n\tbackground: transparent;\n\tborder: none;\n\toutline: none;\n\tuser-select: none;\n\tfont-family: monospace;\n\tfont-weight: bold;\n\tfont-size: 1.4rem;\n\tcolor: #fff;\n\topacity: 0.75;\n\ttransition: opacity 0.3s;\n}\n\nbutton::before {\n\tcontent: '';\n\tposition: absolute;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\tleft: 0;\n\tbackground-color: rgba(255, 255, 255, 0.15);\n\ttransform: scale(0, 0);\n\topacity: 0;\n\ttransition: opacity 0.3s, transform 0.3s;\n}\n\n/* No \\`:focus\\` styles because this is a mouse/touch game! */\nbutton:active {\n\topacity: 1;\n}\n\nbutton:active::before {\n\ttransform: scale(1, 1);\n\topacity: 1;\n}\n\n.credits {\n\tposition: fixed;\n\twidth: 100%;\n\tleft: 0;\n\tbottom: 20px;\n}\n\na {\n\tcolor: white;\n}\n\n/* Only enable hover state on large screens */\n@media (min-width: 1025px) {\n\tbutton:hover {\n\t\topacity: 1;\n\t}\n\n\tbutton:hover::before {\n\t\ttransform: scale(1, 1);\n\t\topacity: 1;\n\t}\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://blockninja/./src/client/styles.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://blockninja/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://blockninja/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/client/styles.css":
/*!*******************************!*\
  !*** ./src/client/styles.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/client/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://blockninja/./src/client/styles.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://blockninja/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://blockninja/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://blockninja/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://blockninja/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://blockninja/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://blockninja/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/client/index.js":
/*!*****************************!*\
  !*** ./src/client/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ \"./src/client/styles.css\");\n\n// This is the user data\nconst url = \"https://flask-bninja.ey.r.appspot.com\";\nconst network = __webpack_require__(/*! ./network.js */ \"./src/client/network.js\");\nconst jsonData = new network.JsonData();\njsonData.jsonObj = {};\n\n// background color\n\nconst bgColors = [\"red\",\"blue\"];\nconst firstColor = Math.floor(Math.random() * 2.001);\nconst secondColor = 1 - firstColor;\n\nlet currColor = firstColor\n\ndocument.body.style.backgroundColor = bgColors[currColor];\n\nlet startTime;\nlet endTime;\nlet timeSpent;\n\n// globalConfig.js\n// Provides global variables used by the entire program.\n// Most of this should be configuration.\n\n// Timing multiplier for entire game engine.\nlet gameSpeed = 1;\n\n// Colors\nconst BLUE =   { r: 0x67, g: 0xd7, b: 0xf0 };\nconst GREEN =  { r: 0xa6, g: 0xe0, b: 0x2c };\nconst PINK =   { r: 0xfa, g: 0x24, b: 0x73 };\nconst ORANGE = { r: 0xfe, g: 0x95, b: 0x22 };\nconst allColors = [BLUE, GREEN, PINK, ORANGE];\n\n// Gameplay\nconst getSpawnDelay = () => {\n\tconst spawnDelayMax = 900;\n\tconst spawnDelayMin = 400;\n\tconst spawnDelay = spawnDelayMax - state.game.cubeCount * 3.1;\n\treturn Math.max(spawnDelay, spawnDelayMin);\n}\nconst doubleStrongEnableScore = 2000;\n// Number of cubes that must be smashed before activating a feature.\nconst slowmoThreshold = 10;\nconst strongThreshold = 25;\nconst spinnerThreshold = 25;\n\n// Interaction state\nlet pointerIsDown = false;\n// The last known position of the primary pointer in screen coordinates.`\nlet pointerScreen = { x: 0, y: 0 };\n// Same as `pointerScreen`, but converted to scene coordinates in rAF.\nlet pointerScene = { x: 0, y: 0 };\n// Minimum speed of pointer before \"hits\" are counted.\nconst minPointerSpeed = 60;\n// The hit speed affects the direction the target post-hit. This number dampens that force.\nconst hitDampening = 0.1;\n// Backboard receives shadows and is the farthest negative Z position of entities.\nconst backboardZ = -400;\nconst shadowColor = '#262e36';\n// How much air drag is applied to standard objects\nconst airDrag = 0.022;\nconst gravity = 0.3;\n// Spark config\nconst sparkColor = 'rgba(170,221,255,.9)';\nconst sparkThickness = 2.2;\nconst airDragSpark = 0.1;\n// Track pointer positions to show trail\nconst touchTrailColor = 'rgba(170,221,255,.62)';\nconst touchTrailThickness = 7;\nconst touchPointLife = 120;\nconst touchPoints = [];\n// Size of in-game targets. This affects rendered size and hit area.\nconst targetRadius = 40;\nconst targetHitRadius = 50;\nconst makeTargetGlueColor = target => {\n\t// const alpha = (target.health - 1) / (target.maxHealth - 1);\n\t// return `rgba(170,221,255,${alpha.toFixed(3)})`;\n\treturn 'rgb(170,221,255)';\n};\n// Size of target fragments\nconst fragRadius = targetRadius / 3;\n\n\n\n// Game canvas element needed in setup.js and interaction.js\nconst canvas = document.querySelector('#c');\n\n// 3D camera config\n// Affects perspective\nconst cameraDistance = 900;\n// Does not affect perspective\nconst sceneScale = 1;\n// Objects that get too close to the camera will be faded out to transparent over this range.\n// const cameraFadeStartZ = 0.8*cameraDistance - 6*targetRadius;\nconst cameraFadeStartZ = 0.45*cameraDistance;\nconst cameraFadeEndZ = 0.65*cameraDistance;\nconst cameraFadeRange = cameraFadeEndZ - cameraFadeStartZ;\n\n// Globals used to accumlate all vertices/polygons in each frame\nconst allVertices = [];\nconst allPolys = [];\nconst allShadowVertices = [];\nconst allShadowPolys = [];\n\n\n\n\n// state.js\n///////////\n// Enums //\n///////////\n\n// Game Modes\nconst GAME_MODE_RANKED = Symbol('GAME_MODE_RANKED');\n\n// Available Menus\nconst MENU_MAIN = Symbol('MENU_MAIN');\nconst MENU_SCORE = Symbol('MENU_SCORE');\n\n\n\n//////////////////\n// Global State //\n//////////////////\n\nconst state = {\n\tgame: {\n\t\tmode: GAME_MODE_RANKED,\n\t\t// Run time of current game.\n\t\ttime: 0,\n\t\t// Player score.\n\t\tscore: 0,\n\t\t// Total number of cubes smashed in game.\n\t\tcubeCount: 0,\n\t\t// The number of times player has played in session\n\t\tsessionTry: 0\n\t},\n\tmenus: {\n\t\t// Set to `null` to hide all menus\n\t\tactive: MENU_MAIN\n\t}\n};\n\n\n////////////////////////////\n// Global State Selectors //\n////////////////////////////\n\nconst isInGame = () => !state.menus.active;\nconst isMenuVisible = () => !!state.menus.active;\n\n\n///////////////////\n// Local Storage //\n///////////////////\n\nconst highScoreKey = '__menja__highScore';\nconst getHighScore = () => {\n\tconst raw = localStorage.getItem(highScoreKey);\n\treturn raw ? parseInt(raw, 10) : -1;\n};\n\nlet _lastHighscore = getHighScore();\nconst setHighScore = score => {\n\t_lastHighscore = getHighScore();\n\tlocalStorage.setItem(highScoreKey, String(score));\n};\n\nconst isNewHighScore = () => state.game.score > _lastHighscore;\n\nwindow.addEventListener('beforeunload', function(event) {\n\tlocalStorage.removeItem(highScoreKey);\n});\n  \n\n\n/////////\n// DOM //\n/////////\n\nconst $ = selector => document.querySelector(selector);\nconst handleClick = (element, handler) => element.addEventListener('click', handler);\nconst handlePointerDown = (element, handler) => {\n\telement.addEventListener('touchstart', handler);\n\telement.addEventListener('mousedown', handler);\n};\n\n\n\n////////////////////////\n// Formatting Helpers //\n////////////////////////\n\n// Converts a number into a formatted string with thousand separators.\nconst formatNumber = num => num.toLocaleString();\n\n\n////////////////////\n// Math Constants //\n////////////////////\n\nconst PI = Math.PI;\nconst TAU = Math.PI * 2;\nconst ETA = Math.PI * 0.5;\n\n//////////////////\n// Math Helpers //\n//////////////////\n\n// Clamps a number between min and max values (inclusive)\nconst clamp = (num, min, max) => Math.min(Math.max(num, min), max);\n\n// Linearly interpolate between numbers a and b by a specific amount.\n// mix >= 0 && mix <= 1\nconst lerp = (a, b, mix) => (b - a) * mix + a;\n\n////////////////////\n// Random Helpers //\n////////////////////\n\n// Generates a random number between min (inclusive) and max (exclusive)\nconst random = (min, max) => Math.random() * (max - min) + min;\n\n// Generates a random integer between and possibly including min and max values\nconst randomInt = (min, max) => ((Math.random() * (max - min + 1)) | 0) + min;\n\n// Returns a random element from an array\nconst pickOne = arr => arr[Math.random() * arr.length | 0];\n\n\n///////////////////\n// Color Helpers //\n///////////////////\n\n// Converts an { r, g, b } color object to a 6-digit hex code.\nconst colorToHex = color => {\n\treturn '#' +\n\t\t(color.r | 0).toString(16).padStart(2, '0') +\n\t\t(color.g | 0).toString(16).padStart(2, '0') +\n\t\t(color.b | 0).toString(16).padStart(2, '0');\n};\n\n// Operates on an { r, g, b } color object.\n// Returns string hex code.\n// `lightness` must range from 0 to 1. 0 is pure black, 1 is pure white.\nconst shadeColor = (color, lightness) => {\n\tlet other, mix;\n\tif (lightness < 0.5) {\n\t\tother = 0;\n\t\tmix = 1 - (lightness * 2);\n\t} else {\n\t\tother = 255;\n\t\tmix = lightness * 2 - 1;\n\t}\n\treturn '#' +\n\t\t(lerp(color.r, other, mix) | 0).toString(16).padStart(2, '0') +\n\t\t(lerp(color.g, other, mix) | 0).toString(16).padStart(2, '0') +\n\t\t(lerp(color.b, other, mix) | 0).toString(16).padStart(2, '0');\n};\n\n////////////////////\n// Timing Helpers //\n////////////////////\n\nconst _allCooldowns = [];\n\nconst makeCooldown = (rechargeTime, units=1) => {\n\tlet timeRemaining = 0;\n\tlet lastTime = 0;\n\n\tconst initialOptions = { rechargeTime, units };\n\n\tconst updateTime = () => {\n\t\tconst now = state.game.time;\n\t\t// Reset time remaining if time goes backwards.\n\t\tif (now < lastTime) {\n\t\t\ttimeRemaining = 0;\n\t\t} else {\n\t\t\t// update...\n\t\t\ttimeRemaining -= now-lastTime;\n\t\t\tif (timeRemaining < 0) timeRemaining = 0;\n\t\t}\n\t\tlastTime = now;\n\t};\n\n\tconst canUse = () => {\n\t\tupdateTime();\n\t\treturn timeRemaining <= (rechargeTime * (units-1));\n\t};\n\n\tconst cooldown = {\n\t\tcanUse,\n\t\tuseIfAble() {\n\t\t\tconst usable = canUse();\n\t\t\tif (usable) timeRemaining += rechargeTime;\n\t\t\treturn usable;\n\t\t},\n\t\tmutate(options) {\n\t\t\tif (options.rechargeTime) {\n\t\t\t\t// Apply recharge time delta so change takes effect immediately.\n\t\t\t\ttimeRemaining -= rechargeTime-options.rechargeTime;\n\t\t\t\tif (timeRemaining < 0) timeRemaining = 0;\n\t\t\t\trechargeTime = options.rechargeTime;\n\t\t\t}\n\t\t\tif (options.units) units = options.units;\n\t\t},\n\t\treset() {\n\t\t\ttimeRemaining = 0;\n\t\t\tlastTime = 0;\n\t\t\tthis.mutate(initialOptions);\n\t\t}\n\t};\n\n\t_allCooldowns.push(cooldown);\n\n\treturn cooldown;\n};\n\nconst resetAllCooldowns = () => _allCooldowns.forEach(cooldown => cooldown.reset());\n\nconst makeSpawner = ({ chance, cooldownPerSpawn, maxSpawns }) => {\n\tconst cooldown = makeCooldown(cooldownPerSpawn, maxSpawns);\n\treturn {\n\t\tshouldSpawn() {\n\t\t\treturn Math.random() <= chance && cooldown.useIfAble();\n\t\t},\n\t\tmutate(options) {\n\t\t\tif (options.chance) chance = options.chance;\n\t\t\tcooldown.mutate({\n\t\t\t\trechargeTime: options.cooldownPerSpawn,\n\t\t\t\tunits: options.maxSpawns\n\t\t\t});\n\t\t}\n\t};\n};\n\n////////////////////\n// Vector Helpers //\n////////////////////\n\nconst normalize = v => {\n\tconst mag = Math.hypot(v.x, v.y, v.z);\n\treturn {\n\t\tx: v.x / mag,\n\t\ty: v.y / mag,\n\t\tz: v.z / mag\n\t};\n}\n\n// Curried math helpers\nconst add = a => b => a + b;\n// Curried vector helpers\nconst scaleVector = scale => vector => {\n\tvector.x *= scale;\n\tvector.y *= scale;\n\tvector.z *= scale;\n};\n\n////////////////\n// 3D Helpers //\n////////////////\n\n// Clone array and all vertices.\nfunction cloneVertices(vertices) {\n\treturn vertices.map(v => ({ x: v.x, y: v.y, z: v.z }));\n}\n\n// Copy vertex data from one array into another.\n// Arrays must be the same length.\nfunction copyVerticesTo(arr1, arr2) {\n\tconst len = arr1.length;\n\tfor (let i=0; i<len; i++) {\n\t\tconst v1 = arr1[i];\n\t\tconst v2 = arr2[i];\n\t\tv2.x = v1.x;\n\t\tv2.y = v1.y;\n\t\tv2.z = v1.z;\n\t}\n}\n\n// Compute triangle midpoint.\n// Mutates `middle` property of given `poly`.\nfunction computeTriMiddle(poly) {\n\tconst v = poly.vertices;\n\tpoly.middle.x = (v[0].x + v[1].x + v[2].x) / 3;\n\tpoly.middle.y = (v[0].y + v[1].y + v[2].y) / 3;\n\tpoly.middle.z = (v[0].z + v[1].z + v[2].z) / 3;\n}\n\n// Compute quad midpoint.\n// Mutates `middle` property of given `poly`.\nfunction computeQuadMiddle(poly) {\n\tconst v = poly.vertices;\n\tpoly.middle.x = (v[0].x + v[1].x + v[2].x + v[3].x) / 4;\n\tpoly.middle.y = (v[0].y + v[1].y + v[2].y + v[3].y) / 4;\n\tpoly.middle.z = (v[0].z + v[1].z + v[2].z + v[3].z) / 4;\n}\n\nfunction computePolyMiddle(poly) {\n\tif (poly.vertices.length === 3) {\n\t\tcomputeTriMiddle(poly);\n\t} else {\n\t\tcomputeQuadMiddle(poly);\n\t}\n}\n\n// Compute distance from any polygon (tri or quad) midpoint to camera.\n// Sets `depth` property of given `poly`.\n// Also triggers midpoint calculation, which mutates `middle` property of `poly`.\nfunction computePolyDepth(poly) {\n\tcomputePolyMiddle(poly);\n\tconst dX = poly.middle.x;\n\tconst dY = poly.middle.y;\n\tconst dZ = poly.middle.z - cameraDistance;\n\tpoly.depth = Math.hypot(dX, dY, dZ);\n}\n\n// Compute normal of any polygon. Uses normalized vector cross product.\n// Mutates `normalName` property of given `poly`.\nfunction computePolyNormal(poly, normalName) {\n\t// Store quick refs to vertices\n\tconst v1 = poly.vertices[0];\n\tconst v2 = poly.vertices[1];\n\tconst v3 = poly.vertices[2];\n\t// Calculate difference of vertices, following winding order.\n\tconst ax = v1.x - v2.x;\n\tconst ay = v1.y - v2.y;\n\tconst az = v1.z - v2.z;\n\tconst bx = v1.x - v3.x;\n\tconst by = v1.y - v3.y;\n\tconst bz = v1.z - v3.z;\n\t// Cross product\n\tconst nx = ay*bz - az*by;\n\tconst ny = az*bx - ax*bz;\n\tconst nz = ax*by - ay*bx;\n\t// Compute magnitude of normal and normalize\n\tconst mag = Math.hypot(nx, ny, nz);\n\tconst polyNormal = poly[normalName];\n\tpolyNormal.x = nx / mag;\n\tpolyNormal.y = ny / mag;\n\tpolyNormal.z = nz / mag;\n}\n\n// Apply translation/rotation/scale to all given vertices.\n// If `vertices` and `target` are the same array, the vertices will be mutated in place.\n// If `vertices` and `target` are different arrays, `vertices` will not be touched, instead the\n// transformed values from `vertices` will be written to `target` array.\nfunction transformVertices(vertices, target, tX, tY, tZ, rX, rY, rZ, sX, sY, sZ) {\n\t// Matrix multiplcation constants only need calculated once for all vertices.\n\tconst sinX = Math.sin(rX);\n\tconst cosX = Math.cos(rX);\n\tconst sinY = Math.sin(rY);\n\tconst cosY = Math.cos(rY);\n\tconst sinZ = Math.sin(rZ);\n\tconst cosZ = Math.cos(rZ);\n\n\t// Using forEach() like map(), but with a (recycled) target array.\n\tvertices.forEach((v, i) => {\n\t\tconst targetVertex = target[i];\n\t\t// X axis rotation\n\t\tconst x1 = v.x;\n\t\tconst y1 = v.z*sinX + v.y*cosX;\n\t\tconst z1 = v.z*cosX - v.y*sinX;\n\t\t// Y axis rotation\n\t\tconst x2 = x1*cosY - z1*sinY;\n\t\tconst y2 = y1;\n\t\tconst z2 = x1*sinY + z1*cosY;\n\t\t// Z axis rotation\n\t\tconst x3 = x2*cosZ - y2*sinZ;\n\t\tconst y3 = x2*sinZ + y2*cosZ;\n\t\tconst z3 = z2;\n\n\t\t// Scale, Translate, and set the transform.\n\t\ttargetVertex.x = x3 * sX + tX;\n\t\ttargetVertex.y = y3 * sY + tY;\n\t\ttargetVertex.z = z3 * sZ + tZ;\n\t});\n}\n\n// 3D projection on a single vertex.\n// Directly mutates the vertex.\nconst projectVertex = v => {\n\tconst focalLength = cameraDistance * sceneScale;\n\tconst depth = focalLength / (cameraDistance - v.z);\n\tv.x = v.x * depth;\n\tv.y = v.y * depth;\n};\n\n// 3D projection on a single vertex.\n// Mutates a secondary target vertex.\nconst projectVertexTo = (v, target) => {\n\tconst focalLength = cameraDistance * sceneScale;\n\tconst depth = focalLength / (cameraDistance - v.z);\n\ttarget.x = v.x * depth;\n\ttarget.y = v.y * depth;\n};\n\n// PERF.js\n// Dummy no-op functions.\n// I use these in a special build for custom performance profiling.\nconst PERF_START = () => {};\nconst PERF_END = () => {};\nconst PERF_UPDATE = () => {};\n\n\n\n\n// 3dModels.js\n// Define models once. The origin is the center of the model.\n\n// A simple cube, 8 vertices, 6 quads.\n// Defaults to an edge length of 2 units, can be influenced with `scale`.\nfunction makeCubeModel({ scale=1 }) {\n\treturn {\n\t\tvertices: [\n\t\t\t// top\n\t\t\t{ x: -scale, y: -scale, z: scale },\n\t\t\t{ x:  scale, y: -scale, z: scale },\n\t\t\t{ x:  scale, y:  scale, z: scale },\n\t\t\t{ x: -scale, y:  scale, z: scale },\n\t\t\t// bottom\n\t\t\t{ x: -scale, y: -scale, z: -scale },\n\t\t\t{ x:  scale, y: -scale, z: -scale },\n\t\t\t{ x:  scale, y:  scale, z: -scale },\n\t\t\t{ x: -scale, y:  scale, z: -scale }\n\t\t],\n\t\tpolys: [\n\t\t\t// z = 1\n\t\t\t{ vIndexes: [0, 1, 2, 3] },\n\t\t\t// z = -1\n\t\t\t{ vIndexes: [7, 6, 5, 4] },\n\t\t\t// y = 1\n\t\t\t{ vIndexes: [3, 2, 6, 7] },\n\t\t\t// y = -1\n\t\t\t{ vIndexes: [4, 5, 1, 0] },\n\t\t\t// x = 1\n\t\t\t{ vIndexes: [5, 6, 2, 1] },\n\t\t\t// x = -1\n\t\t\t{ vIndexes: [0, 3, 7, 4] }\n\t\t]\n\t};\n}\n\n// Not very optimized - lots of duplicate vertices are generated.\nfunction makeRecursiveCubeModel({ recursionLevel, splitFn, color, scale=1 }) {\n\tconst getScaleAtLevel = level => 1 / (3 ** level);\n\n\t// We can model level 0 manually. It's just a single, centered, cube.\n\tlet cubeOrigins = [{ x: 0, y: 0, z: 0 }];\n\n\t// Recursively replace cubes with smaller cubes.\n\tfor (let i=1; i<=recursionLevel; i++) {\n\t\tconst scale = getScaleAtLevel(i) * 2;\n\t\tconst cubeOrigins2 = [];\n\t\tcubeOrigins.forEach(origin => {\n\t\t\tcubeOrigins2.push(...splitFn(origin, scale));\n\t\t});\n\t\tcubeOrigins = cubeOrigins2;\n\t}\n\n\tconst finalModel = { vertices: [], polys: [] };\n\n\t// Generate single cube model and scale it.\n\tconst cubeModel = makeCubeModel({ scale: 1 });\n\tcubeModel.vertices.forEach(scaleVector(getScaleAtLevel(recursionLevel)));\n\n\t// Compute the max distance x, y, or z origin values will be.\n\t// Same result as `Math.max(...cubeOrigins.map(o => o.x))`, but much faster.\n\tconst maxComponent = getScaleAtLevel(recursionLevel) * (3 ** recursionLevel - 1);\n\n\t// Place cube geometry at each origin.\n\tcubeOrigins.forEach((origin, cubeIndex) => {\n\t\t// To compute occlusion (shading), find origin component with greatest\n\t\t// magnitude and normalize it relative to `maxComponent`.\n\t\tconst occlusion = Math.max(\n\t\t\tMath.abs(origin.x),\n\t\t\tMath.abs(origin.y),\n\t\t\tMath.abs(origin.z)\n\t\t) / maxComponent;\n\t\t// At lower iterations, occlusion looks better lightened up a bit.\n\t\tconst occlusionLighter = recursionLevel > 2\n\t\t\t? occlusion\n\t\t\t: (occlusion + 0.8) / 1.8;\n\t\t// Clone, translate vertices to origin, and apply scale\n\t\tfinalModel.vertices.push(\n\t\t\t...cubeModel.vertices.map(v => ({\n\t\t\t\tx: (v.x + origin.x) * scale,\n\t\t\t\ty: (v.y + origin.y) * scale,\n\t\t\t\tz: (v.z + origin.z) * scale\n\t\t\t}))\n\t\t);\n\t\t// Clone polys, shift referenced vertex indexes, and compute color.\n\t\tfinalModel.polys.push(\n\t\t\t...cubeModel.polys.map(poly => ({\n\t\t\t\tvIndexes: poly.vIndexes.map(add(cubeIndex * 8))\n\t\t\t}))\n\t\t);\n\t});\n\n\treturn finalModel;\n}\n\n\n// o: Vector3D - Position of cube's origin (center).\n// s: Vector3D - Determines size of menger sponge.\nfunction mengerSpongeSplit(o, s) {\n\treturn [\n\t\t// Top\n\t\t{ x: o.x + s, y: o.y - s, z: o.z + s },\n\t\t{ x: o.x + s, y: o.y - s, z: o.z + 0 },\n\t\t{ x: o.x + s, y: o.y - s, z: o.z - s },\n\t\t{ x: o.x + 0, y: o.y - s, z: o.z + s },\n\t\t{ x: o.x + 0, y: o.y - s, z: o.z - s },\n\t\t{ x: o.x - s, y: o.y - s, z: o.z + s },\n\t\t{ x: o.x - s, y: o.y - s, z: o.z + 0 },\n\t\t{ x: o.x - s, y: o.y - s, z: o.z - s },\n\t\t// Bottom\n\t\t{ x: o.x + s, y: o.y + s, z: o.z + s },\n\t\t{ x: o.x + s, y: o.y + s, z: o.z + 0 },\n\t\t{ x: o.x + s, y: o.y + s, z: o.z - s },\n\t\t{ x: o.x + 0, y: o.y + s, z: o.z + s },\n\t\t{ x: o.x + 0, y: o.y + s, z: o.z - s },\n\t\t{ x: o.x - s, y: o.y + s, z: o.z + s },\n\t\t{ x: o.x - s, y: o.y + s, z: o.z + 0 },\n\t\t{ x: o.x - s, y: o.y + s, z: o.z - s },\n\t\t// Middle\n\t\t{ x: o.x + s, y: o.y + 0, z: o.z + s },\n\t\t{ x: o.x + s, y: o.y + 0, z: o.z - s },\n\t\t{ x: o.x - s, y: o.y + 0, z: o.z + s },\n\t\t{ x: o.x - s, y: o.y + 0, z: o.z - s }\n\t];\n}\n\n\n\n// Helper to optimize models by merging duplicate vertices within a threshold,\n// and removing all polys that share the same vertices.\n// Directly mutates the model.\nfunction optimizeModel(model, threshold=0.0001) {\n\tconst { vertices, polys } = model;\n\n\tconst compareVertices = (v1, v2) => (\n\t\tMath.abs(v1.x - v2.x) < threshold &&\n\t\tMath.abs(v1.y - v2.y) < threshold &&\n\t\tMath.abs(v1.z - v2.z) < threshold\n\t);\n\n\tconst comparePolys = (p1, p2) => {\n\t\tconst v1 = p1.vIndexes;\n\t\tconst v2 = p2.vIndexes;\n\t\treturn (\n\t\t\t(\n\t\t\t\tv1[0] === v2[0] ||\n\t\t\t\tv1[0] === v2[1] ||\n\t\t\t\tv1[0] === v2[2] ||\n\t\t\t\tv1[0] === v2[3]\n\t\t\t) && (\n\t\t\t\tv1[1] === v2[0] ||\n\t\t\t\tv1[1] === v2[1] ||\n\t\t\t\tv1[1] === v2[2] ||\n\t\t\t\tv1[1] === v2[3]\n\t\t\t) && (\n\t\t\t\tv1[2] === v2[0] ||\n\t\t\t\tv1[2] === v2[1] ||\n\t\t\t\tv1[2] === v2[2] ||\n\t\t\t\tv1[2] === v2[3]\n\t\t\t) && (\n\t\t\t\tv1[3] === v2[0] ||\n\t\t\t\tv1[3] === v2[1] ||\n\t\t\t\tv1[3] === v2[2] ||\n\t\t\t\tv1[3] === v2[3]\n\t\t\t)\n\t\t);\n\t};\n\n\n\tvertices.forEach((v, i) => {\n\t\tv.originalIndexes = [i];\n\t});\n\n\tfor (let i=vertices.length-1; i>=0; i--) {\n\t\tfor (let ii=i-1; ii>=0; ii--) {\n\t\t\tconst v1 = vertices[i];\n\t\t\tconst v2 = vertices[ii];\n\t\t\tif (compareVertices(v1, v2)) {\n\t\t\t\tvertices.splice(i, 1);\n\t\t\t\tv2.originalIndexes.push(...v1.originalIndexes);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvertices.forEach((v, i) => {\n\t\tpolys.forEach(p => {\n\t\t\tp.vIndexes.forEach((vi, ii, arr) => {\n\t\t\t\tconst vo = v.originalIndexes;\n\t\t\t\tif (vo.includes(vi)) {\n\t\t\t\t\tarr[ii] = i;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n\n\tpolys.forEach(p => {\n\t\tconst vi = p.vIndexes;\n\t\tp.sum = vi[0] + vi[1] + vi[2] + vi[3];\n\t});\n\tpolys.sort((a, b) => b.sum - a.sum);\n\n\t// Assumptions:\n\t// 1. Each poly will either have no duplicates or 1 duplicate.\n\t// 2. If two polys are equal, they are both hidden (two cubes touching),\n\t//    therefore both can be removed.\n\tfor (let i=polys.length-1; i>=0; i--) {\n\t\tfor (let ii=i-1; ii>=0; ii--) {\n\t\t\tconst p1 = polys[i];\n\t\t\tconst p2 = polys[ii];\n\t\t\tif (p1.sum !== p2.sum) break;\n\t\t\tif (comparePolys(p1, p2)) {\n\t\t\t\tpolys.splice(i, 1);\n\t\t\t\tpolys.splice(ii, 1);\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn model;\n}\n\n\n\n\n\n// Entity.js\n\nclass Entity {\n\tconstructor({ model, color, wireframe=false }) {\n\t\tconst vertices = cloneVertices(model.vertices);\n\t\tconst shadowVertices = cloneVertices(model.vertices);\n\t\tconst colorHex = colorToHex(color);\n\t\tconst darkColorHex = shadeColor(color, 0.4);\n\n\t\tconst polys = model.polys.map(p => ({\n\t\t\tvertices: p.vIndexes.map(vIndex => vertices[vIndex]),\n\t\t\tcolor: color, // custom rgb color object\n\t\t\twireframe: wireframe,\n\t\t\tstrokeWidth: wireframe ? 2 : 0, // Set to non-zero value to draw stroke\n\t\t\tstrokeColor: colorHex, // must be a CSS color string\n\t\t\tstrokeColorDark: darkColorHex, // must be a CSS color string\n\t\t\tdepth: 0,\n\t\t\tmiddle: { x: 0, y: 0, z: 0 },\n\t\t\tnormalWorld: { x: 0, y: 0, z: 0 },\n\t\t\tnormalCamera: { x: 0, y: 0, z: 0 }\n\t\t}));\n\n\t\tconst shadowPolys = model.polys.map(p => ({\n\t\t\tvertices: p.vIndexes.map(vIndex => shadowVertices[vIndex]),\n\t\t\twireframe: wireframe,\n\t\t\tnormalWorld: { x: 0, y: 0, z: 0 }\n\t\t}));\n\n\t\tthis.projected = {}; // Will store 2D projected data\n\t\tthis.model = model;\n\t\tthis.vertices = vertices;\n\t\tthis.polys = polys;\n\t\tthis.shadowVertices = shadowVertices;\n\t\tthis.shadowPolys = shadowPolys;\n\t\tthis.reset();\n\t}\n\n\t// Better names: resetEntity, resetTransform, resetEntityTransform\n\treset() {\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t\tthis.z = 0;\n\t\tthis.xD = 0;\n\t\tthis.yD = 0;\n\t\tthis.zD = 0;\n\n\t\tthis.rotateX = 0;\n\t\tthis.rotateY = 0;\n\t\tthis.rotateZ = 0;\n\t\tthis.rotateXD = 0;\n\t\tthis.rotateYD = 0;\n\t\tthis.rotateZD = 0;\n\n\t\tthis.scaleX = 1;\n\t\tthis.scaleY = 1;\n\t\tthis.scaleZ = 1;\n\n\t\tthis.projected.x = 0;\n\t\tthis.projected.y = 0;\n\t}\n\n\ttransform() {\n\t\ttransformVertices(\n\t\t\tthis.model.vertices,\n\t\t\tthis.vertices,\n\t\t\tthis.x,\n\t\t\tthis.y,\n\t\t\tthis.z,\n\t\t\tthis.rotateX,\n\t\t\tthis.rotateY,\n\t\t\tthis.rotateZ,\n\t\t\tthis.scaleX,\n\t\t\tthis.scaleY,\n\t\t\tthis.scaleZ\n\t\t);\n\n\t\tcopyVerticesTo(this.vertices, this.shadowVertices);\n\t}\n\n\t// Projects origin point, stored as `projected` property.\n\tproject() {\n\t\tprojectVertexTo(this, this.projected);\n\t}\n}\n\n// getTarget.js\n// All active targets\nconst targets = [];\n\n// Pool target instances by color, using a Map.\n// keys are color objects, and values are arrays of targets.\n// Also pool wireframe instances separately.\nconst targetPool = new Map(allColors.map(c=>([c, []])));\nconst targetWireframePool = new Map(allColors.map(c=>([c, []])));\n\n\n\nconst getTarget = (() => {\n\n\tconst slowmoSpawner = makeSpawner({\n\t\tchance: 0.5,\n\t\tcooldownPerSpawn: 10000,\n\t\tmaxSpawns: 1\n\t});\n\n\tlet doubleStrong = false;\n\tconst strongSpawner = makeSpawner({\n\t\tchance: 0.3,\n\t\tcooldownPerSpawn: 12000,\n\t\tmaxSpawns: 1\n\t});\n\n\tconst spinnerSpawner = makeSpawner({\n\t\tchance: 0.1,\n\t\tcooldownPerSpawn: 10000,\n\t\tmaxSpawns: 1\n\t});\n\n\t// Cached array instances, no need to allocate every time.\n\tconst axisOptions = [\n\t\t['x', 'y'],\n\t\t['y', 'z'],\n\t\t['z', 'x']\n\t];\n\n\tfunction getTargetOfStyle(color, wireframe) {\n\t\tconst pool = wireframe ? targetWireframePool : targetPool;\n\t\tlet target = pool.get(color).pop();\n\t\tif (!target) {\n\t\t\ttarget = new Entity({\n\t\t\t\tmodel: optimizeModel(makeRecursiveCubeModel({\n\t\t\t\t\trecursionLevel: 1,\n\t\t\t\t\tsplitFn: mengerSpongeSplit,\n\t\t\t\t\tscale: targetRadius\n\t\t\t\t})),\n\t\t\t\tcolor: color,\n\t\t\t\twireframe: wireframe\n\t\t\t});\n\n\t\t\t// Init any properties that will be used.\n\t\t\t// These will not be automatically reset when recycled.\n\t\t\ttarget.color = color;\n\t\t\ttarget.wireframe = wireframe;\n\t\t\t// Some properties don't have their final value yet.\n\t\t\t// Initialize with any value of the right type.\n\t\t\ttarget.hit = false;\n\t\t\ttarget.maxHealth = 0;\n\t\t\ttarget.health = 0;\n\t\t}\n\t\treturn target;\n\t}\n\n\treturn function getTarget() {\n\t\tif (doubleStrong && state.game.score <= doubleStrongEnableScore) {\n\t\t\tdoubleStrong = false;\n\t\t\t// Spawner is reset automatically when game resets.\n\t\t} else if (!doubleStrong && state.game.score > doubleStrongEnableScore) {\n\t\t\tdoubleStrong = true;\n\t\t\tstrongSpawner.mutate({ maxSpawns: 2 });\n\t\t}\n\n\t\t// Target Parameters\n\t\t// --------------------------------\n\t\tlet color = pickOne([BLUE, GREEN, ORANGE]);\n\t\tlet wireframe = false;\n\t\tlet health = 1;\n\t\tlet maxHealth = 3;\n\t\tconst spinner = state.game.cubeCount >= spinnerThreshold && isInGame() && spinnerSpawner.shouldSpawn();\n\n\t\t// Target Parameter Overrides\n\t\t// --------------------------------\n\t\tif (state.game.cubeCount >= slowmoThreshold && slowmoSpawner.shouldSpawn()) {\n\t\t\tcolor = BLUE;\n\t\t\twireframe = true;\n\t\t}\n\t\telse if (state.game.cubeCount >= strongThreshold && strongSpawner.shouldSpawn()) {\n\t\t\tcolor = PINK;\n\t\t\thealth = 3;\n\t\t}\n\n\t\t// Target Creation\n\t\t// --------------------------------\n\t\tconst target = getTargetOfStyle(color, wireframe);\n\t\ttarget.hit = false;\n\t\ttarget.maxHealth = maxHealth;\n\t\ttarget.health = health;\n\t\tupdateTargetHealth(target, 0);\n\n\t\tconst spinSpeeds = [\n\t\t\tMath.random() * 0.1 - 0.05,\n\t\t\tMath.random() * 0.1 - 0.05\n\t\t];\n\n\t\tif (spinner) {\n\t\t\t// Ends up spinning a random axis\n\t\t\tspinSpeeds[0] = -0.25;\n\t\t\tspinSpeeds[1] = 0;\n\t\t\ttarget.rotateZ = random(0, TAU);\n\t\t}\n\n\t\tconst axes = pickOne(axisOptions);\n\n\t\tspinSpeeds.forEach((spinSpeed, i) => {\n\t\t\tswitch (axes[i]) {\n\t\t\t\tcase 'x':\n\t\t\t\t\ttarget.rotateXD = spinSpeed;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'y':\n\t\t\t\t\ttarget.rotateYD = spinSpeed;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z':\n\t\t\t\t\ttarget.rotateZD = spinSpeed;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\treturn target;\n\t}\n})();\n\n\nconst updateTargetHealth = (target, healthDelta) => {\n\ttarget.health += healthDelta;\n\t// Only update stroke on non-wireframe targets.\n\t// Showing \"glue\" is a temporary attempt to display health. For now, there's\n\t// no reason to have wireframe targets with high health, so we're fine.\n\tif (!target.wireframe) {\n\t\tconst strokeWidth = target.health - 1;\n\t\tconst strokeColor = makeTargetGlueColor(target);\n\t\tfor (let p of target.polys) {\n\t\t\tp.strokeWidth = strokeWidth;\n\t\t\tp.strokeColor = strokeColor;\n\t\t}\n\t}\n};\n\n\nconst returnTarget = target => {\n\ttarget.reset();\n\tconst pool = target.wireframe ? targetWireframePool : targetPool;\n\tpool.get(target.color).push(target);\n};\n\n\nfunction resetAllTargets() {\n\twhile(targets.length) {\n\t\treturnTarget(targets.pop());\n\t}\n}\n\n// createBurst.js\n// Track all active fragments\nconst frags = [];\n\n// Pool inactive fragments by color, using a Map.\n// keys are color objects, and values are arrays of fragments.\n// // Also pool wireframe instances separately.\nconst fragPool = new Map(allColors.map(c=>([c, []])));\nconst fragWireframePool = new Map(allColors.map(c=>([c, []])));\n\n\nconst createBurst = (() => {\n\t// Precompute some private data to be reused for all bursts.\n\tconst basePositions = mengerSpongeSplit({ x:0, y:0, z:0 }, fragRadius*2);\n\tconst positions = cloneVertices(basePositions);\n\tconst prevPositions = cloneVertices(basePositions);\n\tconst velocities = cloneVertices(basePositions);\n\n\tconst basePositionNormals = basePositions.map(normalize);\n\tconst positionNormals = cloneVertices(basePositionNormals);\n\n\n\tconst fragCount = basePositions.length;\n\n\tfunction getFragForTarget(target) {\n\t\tconst pool = target.wireframe ? fragWireframePool : fragPool;\n\t\tlet frag = pool.get(target.color).pop();\n\t\tif (!frag) {\n\t\t\tfrag = new Entity({\n\t\t\t\tmodel: makeCubeModel({ scale: fragRadius }),\n\t\t\t\tcolor: target.color,\n\t\t\t\twireframe: target.wireframe\n\t\t\t});\n\t\t\tfrag.color = target.color;\n\t\t\tfrag.wireframe = target.wireframe;\n\t\t}\n\t\treturn frag;\n\t}\n\n\treturn (target, force=1) => {\n\t\t// Calculate fragment positions, and what would have been the previous positions\n\t\t// when still a part of the larger target.\n\t\ttransformVertices(\n\t\t\tbasePositions, positions,\n\t\t\ttarget.x, target.y, target.z,\n\t\t\ttarget.rotateX, target.rotateY, target.rotateZ,\n\t\t\t1, 1, 1\n\t\t);\n\t\ttransformVertices(\n\t\t\tbasePositions, prevPositions,\n\t\t\ttarget.x - target.xD, target.y - target.yD, target.z - target.zD,\n\t\t\ttarget.rotateX - target.rotateXD, target.rotateY - target.rotateYD, target.rotateZ - target.rotateZD,\n\t\t\t1, 1, 1\n\t\t);\n\n\t\t// Compute velocity of each fragment, based on previous positions.\n\t\t// Will write to `velocities` array.\n\t\tfor (let i=0; i<fragCount; i++) {\n\t\t\tconst position = positions[i];\n\t\t\tconst prevPosition = prevPositions[i];\n\t\t\tconst velocity = velocities[i];\n\n\t\t\tvelocity.x = position.x - prevPosition.x;\n\t\t\tvelocity.y = position.y - prevPosition.y;\n\t\t\tvelocity.z = position.z - prevPosition.z;\n\t\t}\n\n\n\n\t\t// Apply target rotation to normals\n\t\ttransformVertices(\n\t\t\tbasePositionNormals, positionNormals,\n\t\t\t0, 0, 0,\n\t\t\ttarget.rotateX, target.rotateY, target.rotateZ,\n\t\t\t1, 1, 1\n\t\t);\n\n\n\t\tfor (let i=0; i<fragCount; i++) {\n\t\t\tconst position = positions[i];\n\t\t\tconst velocity = velocities[i];\n\t\t\tconst normal = positionNormals[i];\n\n\t\t\tconst frag = getFragForTarget(target);\n\n\t\t\tfrag.x = position.x;\n\t\t\tfrag.y = position.y;\n\t\t\tfrag.z = position.z;\n\t\t\tfrag.rotateX = target.rotateX;\n\t\t\tfrag.rotateY = target.rotateY;\n\t\t\tfrag.rotateZ = target.rotateZ;\n\n\n\t\t\tconst burstSpeed = 2 * force;\n\t\t\tconst randSpeed = 2 * force;\n\t\t\tconst rotateScale = 0.015;\n\t\t\tfrag.xD = velocity.x + (normal.x * burstSpeed) + (Math.random() * randSpeed);\n\t\t\tfrag.yD = velocity.y + (normal.y * burstSpeed) + (Math.random() * randSpeed);\n\t\t\tfrag.zD = velocity.z + (normal.z * burstSpeed) + (Math.random() * randSpeed);\n\t\t\tfrag.rotateXD = frag.xD * rotateScale;\n\t\t\tfrag.rotateYD = frag.yD * rotateScale;\n\t\t\tfrag.rotateZD = frag.zD * rotateScale;\n\n\t\t\tfrags.push(frag);\n\t\t};\n\t}\n})();\n\n\nconst returnFrag = frag => {\n\tfrag.reset();\n\tconst pool = frag.wireframe ? fragWireframePool : fragPool;\n\tpool.get(frag.color).push(frag);\n};\n\n\n\n\n\n// sparks.js\nconst sparks = [];\nconst sparkPool = [];\n\n\nfunction addSpark(x, y, xD, yD) {\n\tconst spark = sparkPool.pop() || {};\n\n\tspark.x = x + xD * 0.5;\n\tspark.y = y + yD * 0.5;\n\tspark.xD = xD;\n\tspark.yD = yD;\n\tspark.life = random(200, 300);\n\tspark.maxLife = spark.life;\n\n\tsparks.push(spark);\n\n\treturn spark;\n}\n\n\n// Spherical spark burst\nfunction sparkBurst(x, y, count, maxSpeed) {\n\tconst angleInc = TAU / count;\n\tfor (let i=0; i<count; i++) {\n\t\tconst angle = i * angleInc + angleInc * Math.random();\n\t\tconst speed = (1 - Math.random() ** 3) * maxSpeed;\n\t\taddSpark(\n\t\t\tx,\n\t\t\ty,\n\t\t\tMath.sin(angle) * speed,\n\t\t\tMath.cos(angle) * speed\n\t\t);\n\t}\n}\n\n\n// Make a target \"leak\" sparks from all vertices.\n// This is used to create the effect of target glue \"shedding\".\nlet glueShedVertices;\nfunction glueShedSparks(target) {\n\tif (!glueShedVertices) {\n\t\tglueShedVertices = cloneVertices(target.vertices);\n\t} else {\n\t\tcopyVerticesTo(target.vertices, glueShedVertices);\n\t}\n\n\tglueShedVertices.forEach(v => {\n\t\tif (Math.random() < 0.4) {\n\t\t\tprojectVertex(v);\n\t\t\taddSpark(\n\t\t\t\tv.x,\n\t\t\t\tv.y,\n\t\t\t\trandom(-12, 12),\n\t\t\t\trandom(-12, 12)\n\t\t\t);\n\t\t}\n\t});\n}\n\nfunction returnSpark(spark) {\n\tsparkPool.push(spark);\n}\n\n\n\n\n\n// hud.js\nconst hudContainerNode = $('.hud');\n\nfunction setHudVisibility(visible) {\n\tif (visible) {\n\t\thudContainerNode.style.display = 'block';\n\t} else {\n\t\thudContainerNode.style.display = 'none';\n\t}\n}\n\n\n///////////\n// Score //\n///////////\n\n\n//////////////////\n// Pause Button //\n//////////////////\n\n\n////////////////////\n// Slow-Mo Status //\n////////////////////\n\nconst slowmoNode = $('.slowmo');\nconst slowmoBarNode = $('.slowmo__bar');\n\nfunction renderSlowmoStatus(percentRemaining) {\n\tslowmoNode.style.opacity = percentRemaining === 0 ? 0 : 1;\n\tslowmoBarNode.style.transform = `scaleX(${percentRemaining.toFixed(3)})`;\n}\n\n// menus.js\n// Top-level menu containers\nconst menuContainerNode = $('.menus');\nconst menuMainNode = $('.menu--main');\nconst menuScoreNode = $('.menu--score');\n\n\nfunction showMenu(node) {\n\tnode.classList.add('active');\n}\n\nfunction hideMenu(node) {\n\tnode.classList.remove('active');\n}\n\nfunction renderMenus() {\n\thideMenu(menuMainNode);\n\thideMenu(menuScoreNode);\n\n\tswitch (state.menus.active) {\n\t\tcase MENU_MAIN:\n\t\t\tshowMenu(menuMainNode);\n\t\t\tbreak;\n\t\tcase MENU_SCORE:\n\t\t\tshowMenu(menuScoreNode);\n\t\t\tbreak;\n\t}\n\n\tsetHudVisibility(!isMenuVisible());\n\tmenuContainerNode.classList.toggle('has-active', isMenuVisible());\n\tmenuContainerNode.classList.toggle('interactive-mode', isMenuVisible() && pointerIsDown);\n}\n\nrenderMenus();\n\n\n\n////////////////////\n// Button Actions //\n////////////////////\n\n// Main Menu\nhandleClick($('.play-normal-btn'), () => {\n\tstartTime = performance.now()\n\tsetGameMode(GAME_MODE_RANKED);\n\tsetActiveMenu(null);\n\tresetGame();\n});\n\n// Score Menu\nhandleClick($('.play-again-btn'), () => {\n\tstartTime = performance.now();\n\tsetActiveMenu(null);\n\tresetGame();\n});\n\n////////////////////\n// Button Actions //\n////////////////////\n\n// Main Menu\nhandleClick($('.play-normal-btn'), () => {\n\tsetGameMode(GAME_MODE_RANKED);\n\tsetActiveMenu(null);\n\tresetGame();\n});\n\n// Score Menu\nhandleClick($('.play-again-btn'), () => {\n\tsetActiveMenu(null);\n\tresetGame();\n});\n\n\n// actions.js\n//////////////////\n// MENU ACTIONS //\n//////////////////\n\nfunction setActiveMenu(menu) {\n\tstate.menus.active = menu;\n\trenderMenus();\n}\n\n\n/////////////////\n// HUD ACTIONS //\n/////////////////\n\nfunction setScore(score) {\n\tstate.game.score = score;\n\t// renderScoreHud();\n}\n\nfunction incrementScore(inc) {\n\tif (isInGame()) {\n\t\tstate.game.score += inc;\n\t\tif (state.game.score < 0) {\n\t\t\tstate.game.score = 0;\n\t\t}\n\t\t// renderScoreHud();\n\t}\n}\n\nfunction setCubeCount(count) {\n\tstate.game.cubeCount = count;\n\t// renderScoreHud();\n}\n\nfunction incrementCubeCount(inc) {\n\tif (isInGame()) {\n\t\tstate.game.cubeCount += inc;\n\t\t// renderScoreHud();\n\t}\n}\n\n\n//////////////////\n// GAME ACTIONS //\n//////////////////\n\nfunction setGameMode(mode) {\n\tstate.game.mode = mode;\n}\n\nfunction resetGame() {\n\tresetAllTargets();\n\tstate.game.time = 0;\n\tresetAllCooldowns();\n\tsetScore(0);\n\tsetCubeCount(0);\n\tspawnTime = getSpawnDelay();\n}\n\nfunction resumeGame() {\n\tsetActiveMenu(null);\n}\n\nfunction endGame() {\n\tendTime = performance.now();\n\ttimeSpent = (endTime - startTime)/1000;\n\n\tstate.game.sessionTry += 1;\n\n\thandleCanvasPointerUp();\n\tif (isNewHighScore()) {\n\t\tsetHighScore(state.game.score);\n\t}\n\tnetwork.JsonData.addData([\"bgColor\",\"try\", \"score\", \"high\", \"time\"], [bgColors[currColor], state.game.sessionTry, state.game.score, isNewHighScore(), timeSpent]);\n\tconsole.log(JSON.stringify(network.JsonData.jsonObj));\n\t// let user have a retry or go to questions\n\tif (state.game.sessionTry < 2) {\n\t\tconsole.log(\"%d tries left\", (2-state.game.sessionTry));\n\t\tsetActiveMenu(MENU_SCORE);\n\t} else {\n\t\tif (currColor == secondColor) {\n\t\t\tlocalStorage.removeItem(highScoreKey);\n\t\t\tconst encodedJsonData = encodeURIComponent(JSON.stringify(network.JsonData.jsonObj));\n\t\t\twindow.location.href = \"question.html?data=\" + encodedJsonData;\n\t\t} else {\n\t\t\tstate.game.sessionTry = 0;\n\t\t\tcurrColor = secondColor\n\t\t\tdocument.body.style.backgroundColor = bgColors[currColor];\n\t\t\tsetActiveMenu(MENU_SCORE);\n\t\t}\n\t}\n}\n\n////////////////////////\n// KEYBOARD SHORTCUTS //\n////////////////////////\n\n// tick.js\nlet spawnTime = 0;\nconst maxSpawnX = 450;\nconst pointerDelta = { x: 0, y: 0 };\nconst pointerDeltaScaled = { x: 0, y: 0 };\n\n// Temp slowmo state. Should be relocated once this stabilizes.\nconst slowmoDuration = 1500;\nlet slowmoRemaining = 0;\nlet spawnExtra = 0;\nconst spawnExtraDelay = 300;\nlet targetSpeed = 1;\n\n\nfunction tick(width, height, simTime, simSpeed, lag) {\n\tPERF_START('frame');\n\tPERF_START('tick');\n\n\tstate.game.time += simTime;\n\n\tif (slowmoRemaining > 0) {\n\t\tslowmoRemaining -= simTime;\n\t\tif (slowmoRemaining < 0) {\n\t\t\tslowmoRemaining = 0;\n\t\t}\n\t\ttargetSpeed = pointerIsDown ? 0.075 : 0.3;\n\t} else {\n\t\tconst menuPointerDown = isMenuVisible() && pointerIsDown;\n\t\ttargetSpeed = menuPointerDown ? 0.025 : 1;\n\t}\n\n\trenderSlowmoStatus(slowmoRemaining / slowmoDuration);\n\n\tgameSpeed += (targetSpeed - gameSpeed) / 22 * lag;\n\tgameSpeed = clamp(gameSpeed, 0, 1);\n\n\tconst centerX = width / 2;\n\tconst centerY = height / 2;\n\n\tconst simAirDrag = 1 - (airDrag * simSpeed);\n\tconst simAirDragSpark = 1 - (airDragSpark * simSpeed);\n\n\t// Pointer Tracking\n\t// -------------------\n\n\t// Compute speed and x/y deltas.\n\t// There is also a \"scaled\" variant taking game speed into account. This serves two purposes:\n\t//  - Lag won't create large spikes in speed/deltas\n\t//  - In slow mo, speed is increased proportionately to match \"reality\". Without this boost,\n\t//    it feels like your actions are dampened in slow mo.\n\tconst forceMultiplier = 1 / (simSpeed * 0.75 + 0.25);\n\tpointerDelta.x = 0;\n\tpointerDelta.y = 0;\n\tpointerDeltaScaled.x = 0;\n\tpointerDeltaScaled.y = 0;\n\tconst lastPointer = touchPoints[touchPoints.length - 1];\n\n\tif (pointerIsDown && lastPointer && !lastPointer.touchBreak) {\n\t\tpointerDelta.x = (pointerScene.x - lastPointer.x);\n\t\tpointerDelta.y = (pointerScene.y - lastPointer.y);\n\t\tpointerDeltaScaled.x = pointerDelta.x * forceMultiplier;\n\t\tpointerDeltaScaled.y = pointerDelta.y * forceMultiplier;\n\t}\n\tconst pointerSpeed = Math.hypot(pointerDelta.x, pointerDelta.y);\n\tconst pointerSpeedScaled = pointerSpeed * forceMultiplier;\n\n\t// Track points for later calculations, including drawing trail.\n\ttouchPoints.forEach(p => p.life -= simTime);\n\n\tif (pointerIsDown) {\n\t\ttouchPoints.push({\n\t\t\tx: pointerScene.x,\n\t\t\ty: pointerScene.y,\n\t\t\tlife: touchPointLife\n\t\t});\n\t}\n\n\twhile (touchPoints[0] && touchPoints[0].life <= 0) {\n\t\ttouchPoints.shift();\n\t}\n\n\n\t// Entity Manipulation\n\t// --------------------\n\tPERF_START('entities');\n\n\t// Spawn targets\n\tspawnTime -= simTime;\n\tif (spawnTime <= 0) {\n\t\tif (spawnExtra > 0) {\n\t\t\tspawnExtra--;\n\t\t\tspawnTime = spawnExtraDelay;\n\t\t} else {\n\t\t\tspawnTime = getSpawnDelay();\n\t\t}\n\t\tconst target = getTarget();\n\t\tconst spawnRadius = Math.min(centerX * 0.8, maxSpawnX);\n\t\ttarget.x = (Math.random() * spawnRadius * 2 - spawnRadius);\n\t\ttarget.y = centerY + targetHitRadius * 2;\n\t\ttarget.z = (Math.random() * targetRadius*2 - targetRadius);\n\t\ttarget.xD = Math.random() * (target.x * -2 / 120);\n\t\ttarget.yD = -20;\n\t\ttargets.push(target);\n\t}\n\n\t// Animate targets and remove when offscreen\n\tconst leftBound = -centerX + targetRadius;\n\tconst rightBound = centerX - targetRadius;\n\tconst ceiling = -centerY - 120;\n\tconst boundDamping = 0.4;\n\n\ttargetLoop:\n\tfor (let i = targets.length - 1; i >= 0; i--) {\n\t\tconst target = targets[i];\n\t\ttarget.x += target.xD * simSpeed;\n\t\ttarget.y += target.yD * simSpeed;\n\n\t\tif (target.y < ceiling) {\n\t\t\ttarget.y = ceiling;\n\t\t\ttarget.yD = 0;\n\t\t}\n\n\t\tif (target.x < leftBound) {\n\t\t\ttarget.x = leftBound;\n\t\t\ttarget.xD *= -boundDamping;\n\t\t} else if (target.x > rightBound) {\n\t\t\ttarget.x = rightBound;\n\t\t\ttarget.xD *= -boundDamping;\n\t\t}\n\n\t\tif (target.z < backboardZ) {\n\t\t\ttarget.z = backboardZ;\n\t\t\ttarget.zD *= -boundDamping;\n\t\t}\n\n\t\ttarget.yD += gravity * simSpeed;\n\t\ttarget.rotateX += target.rotateXD * simSpeed;\n\t\ttarget.rotateY += target.rotateYD * simSpeed;\n\t\ttarget.rotateZ += target.rotateZD * simSpeed;\n\t\ttarget.transform();\n\t\ttarget.project();\n\n\t\t// Remove if offscreen\n\t\tif (target.y > centerY + targetHitRadius * 2) {\n\t\t\ttargets.splice(i, 1);\n\t\t\treturnTarget(target);\n\t\t\tif (isInGame()) {\n\t\t\t\tendGame();\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t// If pointer is moving really fast, we want to hittest multiple points along the path.\n\t\t// We can't use scaled pointer speed to determine this, since we care about actual screen\n\t\t// distance covered.\n\t\tconst hitTestCount = Math.ceil(pointerSpeed / targetRadius * 2);\n\t\t// Start loop at `1` and use `<=` check, so we skip 0% and end up at 100%.\n\t\t// This omits the previous point position, and includes the most recent.\n\t\tfor (let ii=1; ii<=hitTestCount; ii++) {\n\t\t\tconst percent = 1 - (ii / hitTestCount);\n\t\t\tconst hitX = pointerScene.x - pointerDelta.x * percent;\n\t\t\tconst hitY = pointerScene.y - pointerDelta.y * percent;\n\t\t\tconst distance = Math.hypot(\n\t\t\t\thitX - target.projected.x,\n\t\t\t\thitY - target.projected.y\n\t\t\t);\n\n\t\t\tif (distance <= targetHitRadius) {\n\t\t\t\t// Hit! (though we don't want to allow hits on multiple sequential frames)\n\t\t\t\tif (!target.hit) {\n\t\t\t\t\ttarget.hit = true;\n\n\t\t\t\t\ttarget.xD += pointerDeltaScaled.x * hitDampening;\n\t\t\t\t\ttarget.yD += pointerDeltaScaled.y * hitDampening;\n\t\t\t\t\ttarget.rotateXD += pointerDeltaScaled.y * 0.001;\n\t\t\t\t\ttarget.rotateYD += pointerDeltaScaled.x * 0.001;\n\n\t\t\t\t\tconst sparkSpeed = 7 + pointerSpeedScaled * 0.125;\n\n\t\t\t\t\tif (pointerSpeedScaled > minPointerSpeed) {\n\t\t\t\t\t\ttarget.health--;\n\t\t\t\t\t\tincrementScore(1);\n\n\t\t\t\t\t\tif (target.health <= 0) {\n\t\t\t\t\t\t\tincrementCubeCount(2);\n\t\t\t\t\t\t\tcreateBurst(target, forceMultiplier);\n\t\t\t\t\t\t\tsparkBurst(hitX, hitY, 8, sparkSpeed);\n\t\t\t\t\t\t\tif (target.wireframe) {\n\t\t\t\t\t\t\t\tslowmoRemaining = slowmoDuration;\n\t\t\t\t\t\t\t\tspawnTime = 0;\n\t\t\t\t\t\t\t\tspawnExtra = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttargets.splice(i, 1);\n\t\t\t\t\t\t\treturnTarget(target);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsparkBurst(hitX, hitY, 8, sparkSpeed);\n\t\t\t\t\t\t\tglueShedSparks(target);\n\t\t\t\t\t\t\tupdateTargetHealth(target, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsparkBurst(hitX, hitY, 3, sparkSpeed);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Break the current loop and continue the outer loop.\n\t\t\t\t// This skips to processing the next target.\n\t\t\t\tcontinue targetLoop;\n\t\t\t}\n\t\t}\n\n\t\t// This code will only run if target hasn't been \"hit\".\n\t\ttarget.hit = false;\n\t}\n\n\t// Animate fragments and remove when offscreen.\n\tconst fragBackboardZ = backboardZ + fragRadius;\n\t// Allow fragments to move off-screen to sides for a while, since shadows are still visible.\n\tconst fragLeftBound = -width;\n\tconst fragRightBound = width;\n\n\tfor (let i = frags.length - 1; i >= 0; i--) {\n\t\tconst frag = frags[i];\n\t\tfrag.x += frag.xD * simSpeed;\n\t\tfrag.y += frag.yD * simSpeed;\n\t\tfrag.z += frag.zD * simSpeed;\n\n\t\tfrag.xD *= simAirDrag;\n\t\tfrag.yD *= simAirDrag;\n\t\tfrag.zD *= simAirDrag;\n\n\t\tif (frag.y < ceiling) {\n\t\t\tfrag.y = ceiling;\n\t\t\tfrag.yD = 0;\n\t\t}\n\n\t\tif (frag.z < fragBackboardZ) {\n\t\t\tfrag.z = fragBackboardZ;\n\t\t\tfrag.zD *= -boundDamping;\n\t\t}\n\n\t\tfrag.yD += gravity * simSpeed;\n\t\tfrag.rotateX += frag.rotateXD * simSpeed;\n\t\tfrag.rotateY += frag.rotateYD * simSpeed;\n\t\tfrag.rotateZ += frag.rotateZD * simSpeed;\n\t\tfrag.transform();\n\t\tfrag.project();\n\n\t\t// Removal conditions\n\t\tif (\n\t\t\t// Bottom of screen\n\t\t\tfrag.projected.y > centerY + targetHitRadius ||\n\t\t\t// Sides of screen\n\t\t\tfrag.projected.x < fragLeftBound ||\n\t\t\tfrag.projected.x > fragRightBound ||\n\t\t\t// Too close to camera\n\t\t\tfrag.z > cameraFadeEndZ\n\t\t) {\n\t\t\tfrags.splice(i, 1);\n\t\t\treturnFrag(frag);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t// 2D sparks\n\tfor (let i = sparks.length - 1; i >= 0; i--) {\n\t\tconst spark = sparks[i];\n\t\tspark.life -= simTime;\n\t\tif (spark.life <= 0) {\n\t\t\tsparks.splice(i, 1);\n\t\t\treturnSpark(spark);\n\t\t\tcontinue;\n\t\t}\n\t\tspark.x += spark.xD * simSpeed;\n\t\tspark.y += spark.yD * simSpeed;\n\t\tspark.xD *= simAirDragSpark;\n\t\tspark.yD *= simAirDragSpark;\n\t\tspark.yD += gravity * simSpeed;\n\t}\n\n\tPERF_END('entities');\n\n\t// 3D transforms\n\t// -------------------\n\n\tPERF_START('3D');\n\n\t// Aggregate all scene vertices/polys\n\tallVertices.length = 0;\n\tallPolys.length = 0;\n\tallShadowVertices.length = 0;\n\tallShadowPolys.length = 0;\n\ttargets.forEach(entity => {\n\t\tallVertices.push(...entity.vertices);\n\t\tallPolys.push(...entity.polys);\n\t\tallShadowVertices.push(...entity.shadowVertices);\n\t\tallShadowPolys.push(...entity.shadowPolys);\n\t});\n\n\tfrags.forEach(entity => {\n\t\tallVertices.push(...entity.vertices);\n\t\tallPolys.push(...entity.polys);\n\t\tallShadowVertices.push(...entity.shadowVertices);\n\t\tallShadowPolys.push(...entity.shadowPolys);\n\t});\n\n\t// Scene calculations/transformations\n\tallPolys.forEach(p => computePolyNormal(p, 'normalWorld'));\n\tallPolys.forEach(computePolyDepth);\n\tallPolys.sort((a, b) => b.depth - a.depth);\n\n\t// Perspective projection\n\tallVertices.forEach(projectVertex);\n\n\tallPolys.forEach(p => computePolyNormal(p, 'normalCamera'));\n\n\tPERF_END('3D');\n\n\tPERF_START('shadows');\n\n\t// Rotate shadow vertices to light source perspective\n\ttransformVertices(\n\t\tallShadowVertices,\n\t\tallShadowVertices,\n\t\t0, 0, 0,\n\t\tTAU/8, 0, 0,\n\t\t1, 1, 1\n\t);\n\n\tallShadowPolys.forEach(p => computePolyNormal(p, 'normalWorld'));\n\n\tconst shadowDistanceMult = Math.hypot(1, 1);\n\tconst shadowVerticesLength = allShadowVertices.length;\n\tfor (let i=0; i<shadowVerticesLength; i++) {\n\t\tconst distance = allVertices[i].z - backboardZ;\n\t\tallShadowVertices[i].z -= shadowDistanceMult * distance;\n\t}\n\ttransformVertices(\n\t\tallShadowVertices,\n\t\tallShadowVertices,\n\t\t0, 0, 0,\n\t\t-TAU/8, 0, 0,\n\t\t1, 1, 1\n\t);\n\tallShadowVertices.forEach(projectVertex);\n\n\tPERF_END('shadows');\n\n\tPERF_END('tick');\n}\n\n// draw.js\nfunction draw(ctx, width, height, viewScale) {\n\tPERF_START('draw');\n\n\tconst halfW = width / 2;\n\tconst halfH = height / 2;\n\n\n\t// 3D Polys\n\t// ---------------\n\tctx.lineJoin = 'bevel';\n\n\tPERF_START('drawShadows');\n\tctx.fillStyle = shadowColor;\n\tctx.strokeStyle = shadowColor;\n\tallShadowPolys.forEach(p => {\n\t\tif (p.wireframe) {\n\t\t\tctx.lineWidth = 2;\n\t\t\tctx.beginPath();\n\t\t\tconst { vertices } = p;\n\t\t\tconst vCount = vertices.length;\n\t\t\tconst firstV = vertices[0];\n\t\t\tctx.moveTo(firstV.x, firstV.y);\n\t\t\tfor (let i=1; i<vCount; i++) {\n\t\t\t\tconst v = vertices[i];\n\t\t\t\tctx.lineTo(v.x, v.y);\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\tctx.beginPath();\n\t\t\tconst { vertices } = p;\n\t\t\tconst vCount = vertices.length;\n\t\t\tconst firstV = vertices[0];\n\t\t\tctx.moveTo(firstV.x, firstV.y);\n\t\t\tfor (let i=1; i<vCount; i++) {\n\t\t\t\tconst v = vertices[i];\n\t\t\t\tctx.lineTo(v.x, v.y);\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t}\n\t});\n\tPERF_END('drawShadows');\n\n\tPERF_START('drawPolys');\n\n\tallPolys.forEach(p => {\n\t\tif (!p.wireframe && p.normalCamera.z < 0) return;\n\n\t\tif (p.strokeWidth !== 0) {\n\t\t\tctx.lineWidth = p.normalCamera.z < 0 ? p.strokeWidth * 0.5 : p.strokeWidth;\n\t\t\tctx.strokeStyle = p.normalCamera.z < 0 ? p.strokeColorDark : p.strokeColor;\n\t\t}\n\n\t\tconst { vertices } = p;\n\t\tconst lastV = vertices[vertices.length - 1];\n\t\tconst fadeOut = p.middle.z > cameraFadeStartZ;\n\n\t\tif (!p.wireframe) {\n\t\t\tconst normalLight = p.normalWorld.y * 0.5 + p.normalWorld.z * -0.5;\n\t\t\tconst lightness = normalLight > 0\n\t\t\t\t? 0.1\n\t\t\t\t: ((normalLight ** 32 - normalLight) / 2) * 0.9 + 0.1;\n\t\t\tctx.fillStyle = shadeColor(p.color, lightness);\n\t\t}\n\n\t\t// Fade out polys close to camera. `globalAlpha` must be reset later.\n\t\tif (fadeOut) {\n\t\t\t// If polygon gets really close to camera (outside `cameraFadeRange`) the alpha\n\t\t\t// can go negative, which has the appearance of alpha = 1. So, we'll clamp it at 0.\n\t\t\tctx.globalAlpha = Math.max(0, 1 - (p.middle.z - cameraFadeStartZ) / cameraFadeRange);\n\t\t}\n\n\t\tctx.beginPath();\n\t\tctx.moveTo(lastV.x, lastV.y);\n\t\tfor (let v of vertices) {\n\t\t\tctx.lineTo(v.x, v.y);\n\t\t}\n\n\t\tif (!p.wireframe) {\n\t\t\tctx.fill();\n\t\t}\n\t\tif (p.strokeWidth !== 0) {\n\t\t\tctx.stroke();\n\t\t}\n\n\t\tif (fadeOut) {\n\t\t\tctx.globalAlpha = 1;\n\t\t}\n\t});\n\tPERF_END('drawPolys');\n\n\n\tPERF_START('draw2D');\n\n\t// 2D Sparks\n\tctx.strokeStyle = sparkColor;\n\tctx.lineWidth = sparkThickness;\n\tctx.beginPath();\n\tsparks.forEach(spark => {\n\t\tctx.moveTo(spark.x, spark.y);\n\t\t// Shrink sparks to zero length as they die.\n\t\t// Speed up shrinking as life approaches 0 (root curve).\n\t\t// Note that sparks already get smaller over time as their speed slows\n\t\t// down from damping. So this is like a double scale down. To counter this\n\t\t// a bit and keep the sparks larger for longer, we'll also increase the scale\n\t\t// a bit after applying the root curve.\n\t\tconst scale = (spark.life / spark.maxLife) ** 0.5 * 1.5;\n\t\tctx.lineTo(spark.x - spark.xD*scale, spark.y - spark.yD*scale);\n\n\t});\n\tctx.stroke();\n\n\n\t// Touch Strokes\n\t// ---------------\n\n\tctx.strokeStyle = touchTrailColor;\n\tconst touchPointCount = touchPoints.length;\n\tfor (let i=1; i<touchPointCount; i++) {\n\t\tconst current = touchPoints[i];\n\t\tconst prev = touchPoints[i-1];\n\t\tif (current.touchBreak || prev.touchBreak) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst scale = current.life / touchPointLife;\n\t\tctx.lineWidth = scale * touchTrailThickness;\n\t\tctx.beginPath();\n\t\tctx.moveTo(prev.x, prev.y);\n\t\tctx.lineTo(current.x, current.y);\n\t\tctx.stroke();\n\t}\n\n\tPERF_END('draw2D');\n\n\tPERF_END('draw');\n\tPERF_END('frame');\n\n\t// Display performance updates.\n\tPERF_UPDATE();\n}\n\n// canvas.js\nfunction setupCanvas() {\n\tconst ctx = canvas.getContext('2d');\n\t// devicePixelRatio alias\n\tconst dpr = window.devicePixelRatio || 1;\n\t// View will be scaled so objects appear sized similarly on all screen sizes.\n\tlet viewScale;\n\t// Dimensions (taking viewScale into account!)\n\tlet width, height;\n\n\tfunction handleResize() {\n\t\tconst w = window.innerWidth;\n\t\tconst h = window.innerHeight;\n\t\tviewScale = h / 1000;\n\t\twidth = w / viewScale;\n\t\theight = h / viewScale;\n\t\tcanvas.width = w * dpr;\n\t\tcanvas.height = h * dpr;\n\t\tcanvas.style.width = w + 'px';\n\t\tcanvas.style.height = h + 'px';\n\t}\n\n\t// Set initial size\n\thandleResize();\n\t// resize fullscreen canvas\n\twindow.addEventListener('resize', handleResize);\n\n\n\t// Run game loop\n\tlet lastTimestamp = 0;\n\tfunction frameHandler(timestamp) {\n\t\tlet frameTime = timestamp - lastTimestamp;\n\t\tlastTimestamp = timestamp;\n\n\t\t// always queue another frame\n\t\traf();\n\n\t\t// make sure negative time isn't reported (first frame can be whacky)\n\t\tif (frameTime < 0) {\n\t\t\tframeTime = 17;\n\t\t}\n\t\t// - cap minimum framerate to 15fps[~68ms] (assuming 60fps[~17ms] as 'normal')\n\t\telse if (frameTime > 68) {\n\t\t\tframeTime = 68;\n\t\t}\n\n\t\tconst halfW = width / 2;\n\t\tconst halfH = height / 2;\n\n\t\t// Convert pointer position from screen to scene coords.\n\t\tpointerScene.x = pointerScreen.x / viewScale - halfW;\n\t\tpointerScene.y = pointerScreen.y / viewScale - halfH;\n\n\t\tconst lag = frameTime / 16.6667;\n\t\tconst simTime = gameSpeed * frameTime;\n\t\tconst simSpeed = gameSpeed * lag;\n\t\ttick(width, height, simTime, simSpeed, lag);\n\n\t\t// Auto clear canvas\n\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\t// Auto scale drawing for high res displays, and incorporate `viewScale`.\n\t\t// Also shift canvas so (0, 0) is the middle of the screen.\n\t\t// This just works with 3D perspective projection.\n\t\tconst drawScale = dpr * viewScale;\n\t\tctx.scale(drawScale, drawScale);\n\t\tctx.translate(halfW, halfH);\n\t\tdraw(ctx, width, height, viewScale);\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t}\n\tconst raf = () => requestAnimationFrame(frameHandler);\n\t// Start loop\n\traf();\n}\n\n\n\n\n\n// interaction.js\n// ============================================================================\n// ============================================================================\n\n// Interaction\n// -----------------------------\n\nfunction handleCanvasPointerDown(x, y) {\n\tif (!pointerIsDown) {\n\t\tpointerIsDown = true;\n\t\tpointerScreen.x = x;\n\t\tpointerScreen.y = y;\n\t\t// On when menus are open, point down/up toggles an interactive mode.\n\t\t// We just need to rerender the menu system for it to respond.\n\t\tif (isMenuVisible()) renderMenus();\n\t}\n}\n\nfunction handleCanvasPointerUp() {\n\tif (pointerIsDown) {\n\t\tpointerIsDown = false;\n\t\ttouchPoints.push({\n\t\t\ttouchBreak: true,\n\t\t\tlife: touchPointLife\n\t\t});\n\t\t// On when menus are open, point down/up toggles an interactive mode.\n\t\t// We just need to rerender the menu system for it to respond.\n\t\tif (isMenuVisible()) renderMenus();\n\t}\n}\n\nfunction handleCanvasPointerMove(x, y) {\n\tif (pointerIsDown) {\n\t\tpointerScreen.x = x;\n\t\tpointerScreen.y = y;\n\t}\n}\n\n\n// Use pointer events if available, otherwise fallback to touch events (for iOS).\nif ('PointerEvent' in window) {\n\tcanvas.addEventListener('pointerdown', event => {\n\t\tevent.isPrimary && handleCanvasPointerDown(event.clientX, event.clientY);\n\t});\n\n\tcanvas.addEventListener('pointerup', event => {\n\t\tevent.isPrimary && handleCanvasPointerUp();\n\t});\n\n\tcanvas.addEventListener('pointermove', event => {\n\t\tevent.isPrimary && handleCanvasPointerMove(event.clientX, event.clientY);\n\t});\n\n\t// We also need to know if the mouse leaves the page. For this game, it's best if that\n\t// cancels a swipe, so essentially acts as a \"mouseup\" event.\n\tdocument.body.addEventListener('mouseleave', handleCanvasPointerUp);\n} else {\n\tlet activeTouchId = null;\n\tcanvas.addEventListener('touchstart', event => {\n\t\tif (!pointerIsDown) {\n\t\t\tconst touch = event.changedTouches[0];\n\t\t\tactiveTouchId = touch.identifier;\n\t\t\thandleCanvasPointerDown(touch.clientX, touch.clientY);\n\t\t}\n\t});\n\tcanvas.addEventListener('touchend', event => {\n\t\tfor (let touch of event.changedTouches) {\n\t\t\tif (touch.identifier === activeTouchId) {\n\t\t\t\thandleCanvasPointerUp();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\tcanvas.addEventListener('touchmove', event => {\n\t\tfor (let touch of event.changedTouches) {\n\t\t\tif (touch.identifier === activeTouchId) {\n\t\t\t\thandleCanvasPointerMove(touch.clientX, touch.clientY);\n\t\t\t\tevent.preventDefault();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}, { passive: false });\n}\n\nsetupCanvas();\n\n\n//# sourceURL=webpack://blockninja/./src/client/index.js?");

/***/ }),

/***/ "./src/client/network.js":
/*!*******************************!*\
  !*** ./src/client/network.js ***!
  \*******************************/
/***/ ((module) => {

eval("\nclass JsonData {\n    static jsonObj\n\n    constructor() {\n        JsonData.jsonObj = {};\n    }\n\n    static addData(keys, values) {\n        // set first indicators\n        let keyColor = values[0];\n        let gameTry = values[1].toString();\n        if (!JsonData.jsonObj.hasOwnProperty(keyColor)) {\n            JsonData.jsonObj[keyColor] = {}\n        }\n        if (!JsonData.jsonObj[keyColor].hasOwnProperty(gameTry)) {\n            JsonData.jsonObj[keyColor][gameTry] = {}\n        }\n        \n        for (let i = 2; i < keys.length; i++) {\n            let key = keys[i];\n            JsonData.jsonObj[keyColor][gameTry][key] = values[i];\n        }\n    }\n\n    static removeData() { \n        this.jsonObj = {}\n    }\n\n    static storeData(url) {\n        fetch(url + \"/store_data\", {\n            method: \"POST\",\n            body: JSON.stringify(JsonData.jsonObj)\n        })\n       .then(response => response.json())\n       .then(response => console.log(JSON.stringify(response)))\n    }   \n}\n\nmodule.exports = {\n    JsonData\n};\n\n//# sourceURL=webpack://blockninja/./src/client/network.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/client/index.js");
/******/ 	
/******/ })()
;